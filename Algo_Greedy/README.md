# Greedy Algorithm
* **최적해** 를 구하는 데 사용되는 근시안적인 방법
  * 가능한 해들 중에서 **최대** 또는 **최소** 해를 찾는 문제
* 여러 경우 중 하나를 선택 할 때마다 그 순간에 *최적*이라고 생각되는 것을 선택해 나가는 방식으로 진행하여 최종적인 해답에 도달
  * 한번 선택된 것은 번복하지 않는다
  * 지역적으로는 *최적*이지만, 최종적인 해답이 **최적이라는 보장은 없다**
* **원 문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해** 임을 증명해야 한다

## 대표적인 알고리즘
### Prim
* *N* 개의 노드에 대한 **최소 신장 트리(MST)** 를 찾는다
* 서브트리를 확장하면서 *MST* 를 찾는다

### Kruskal
* *N* 개의 노드에 대한 **최소 신장 트리(MST)** 를 찾는다
* 싸이클이 없는 서브 그래프를 확장하면서 *MST* 를 찾는다

### Dijkstra
* 주어진 정점에서 다른 정점들에 대한 **최단 경로**를 찾는다
* 주어진 정점에서 가장 가까운 정점을 찾고, 그 다음 정점을 반복해서 찾는다

## Example
### 거스름돈
* 가장 큰 가치를 가진 동전을 먼저 선택한다
* 동전이 *500, 100, 50, 10* 이라면 **탐욕적**으로 최적해를 구할 수 있다
  * 모든 동전이 서로의 배수이다
* 동전이 *500, 400, 100, 50, 10* 이라면 최적해를 구할 수 없다
  * 가장 큰 가치를 가진 동전을 선택하더라도 *500* 이 *400* 의 배수가 아니기에 반례가 생긴다

### Knapsack
#### 0-1 Knapsack
* 배낭에 물건을 통째로 담아야 하는 문제
* 물건을 쪼갤 수 없는 경우
* 탐욕적 방법으로 최적해를 구하기 어렵다

#### Fractional Kanpsack
* 물건을 부분적으로 담는 것이 허용되는 문제
* 물건을 쪼갤 수 있는 경우
* 탐욕적 방법으로 구할 수 있다
  * 제일 가치가 큰 물건부터 담으면서 무게를 초과하지 않도록 큰 가치의 물건의 일부만 담는다

### [회의실 배정](https://github.com/ljiwoo59/Algorithm_Study/blob/main/Algo_Greedy/MeetingRoomTest.java)
* **탐욕 기법**을 적용한 반복 알고리즘
  * 종료 시간이 **빠른** 순서로 회의를 정렬한다
    * 종료 시간이 같을 시 시작 시간이 빠른 순으로 정렬
  * 첫 번째 (종료 시간이 가장 빠른) 회의를 선택한다
  * 선택한 회의의 종료시간보다 빠른 시작 시간을 가지는 회의를 모두 제거한다
  * 남은 회의들에 대해 앞의 과정을 반복한다
