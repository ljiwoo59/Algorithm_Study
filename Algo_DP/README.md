# Dynamic Programming
* 먼저 **작은 부분 문제들의 해**를 구하고 이들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, **최종적으로 원래 주어진 문제**를 해결하는 알고리즘 설계 기법
* **최적화 문제**를 해결하는 알고리즘
### 분할 정복 vs. 동적계획법
* **분할정복**
  * 연관 없는 부분 문제로 분할
  * 부분 문제를 재귀적으로 해결
  * 부분 문제의 해를 결합
  * 하향식 접근
* **DP**
  * 부분 문제들이 연관이 없으면 적용 불가
  * 부분 문제들은 더 작은 부분 문제들을 공유
  * 모든 부분 문제를 한번만 계산하고 결과를 저장 및 재사용
  * 상향식 접근

## 중복 부분문제 구조 (Overlapping subproblems)
* *순환적인 관계*를 명시적으로 표현하기 위해 **점화식** 사용
* 작은 문제의 해를 **메모이제이션**하여 중복된 계산 방지
### Memoization
* 이전에 계산한 값을 메모리에 저장해서 중복 계산을 방지하는 기술
* 추가적인 메모리 공간 필요


## 최적 부분문제 구조 (Optimal substructure)
* 어떤 문제에 대한 해가 최적일 때, 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다
* *최장경로 (Longest Path) 문제*는 최적의 원칙이 적용되지 않는다
  
## DP 적용 접근 방법
* 최적해 구조의 특성 파악
  * 문제를 부분 문제로 나눈다
* 최적해의 값을 재귀적으로 정의
  * 부분 문제의 최적해 값에 기반하여 문제의 최적해 값 정의
* 상향식 방법으로 최적해 값 계산
  * 가장 작은 부분 문제부터 해를 구하여 테이블에 저장
  * 테이블의 해를 이용해 점차적으로 상위 부분 문제의 최적해를 구한다
  
### 피보나치 수
```java
private static int fibo_dp(n) {
  f[0] = 0;
  f[1] = 1;
  
  for (int i = 2; i <= n; i++)
    f[i] = f[i - 1] + f[i - 2];
  
  return f[n];
}
```
* 반복문을 사용하기에 함수 호출이 발생하지 않는다
* 중복 계산이 없다
* **O(n)**
